<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Zama ‚Ä¢ Private Reaction Test</title>

  <!-- Required for Relayer SDK (WASM / Workers) -->
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin" />
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg-1: #fef9c3;
      --bg-2: #e0f2fe;
      --bg-3: #fce7f3;
      --card-bg: #ffffff;
      --accent: #22c55e;
      --accent-soft: #bbf7d0;
      --accent-strong: #16a34a;
      --text-main: #0f172a;
      --text-muted: #6b7280;
      --border-soft: rgba(148, 163, 184, 0.4);
      --shadow-soft: 0 18px 60px rgba(15, 23, 42, 0.18);
      --radius-xl: 26px;
      --radius-lg: 999px;
      --transition-fast: 150ms ease-out;
      --transition-med: 220ms cubic-bezier(0.19, 1, 0.22, 1);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      color: var(--text-main);
      background: radial-gradient(circle at top left, var(--bg-1), transparent 55%),
        radial-gradient(circle at top right, var(--bg-2), transparent 55%),
        radial-gradient(circle at bottom, var(--bg-3), #f9fafb 65%);
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 20px;
    }

    .app-shell {
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
    }

    .app-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 18px;
      gap: 16px;
      flex-wrap: wrap;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .brand-logo {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: conic-gradient(from 180deg, #22c55e, #0ea5e9, #f97316, #22c55e);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.9),
        0 10px 30px rgba(15, 23, 42, 0.25);
    }

    .brand-logo span {
      font-size: 22px;
      color: #ffffff;
    }

    .brand-text-main {
      font-weight: 700;
      font-size: 22px;
      display: flex;
      align-items: baseline;
      gap: 6px;
      letter-spacing: 0.02em;
    }

    .brand-text-main span:last-child {
      font-weight: 500;
      font-size: 18px;
      color: var(--text-muted);
    }

    .brand-subtitle {
      font-size: 13px;
      color: var(--text-muted);
    }

    .chip-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.35);
      font-size: 12px;
      color: var(--text-muted);
      backdrop-filter: blur(10px);
    }

    .chip.highlight {
      background: rgba(34, 197, 94, 0.1);
      border-color: rgba(34, 197, 94, 0.5);
      color: var(--accent-strong);
      font-weight: 600;
    }

    .btn {
      border: none;
      border-radius: var(--radius-lg);
      padding: 10px 22px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #0f172a;
      color: white;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.35);
      transition: transform var(--transition-fast),
        box-shadow var(--transition-fast), background var(--transition-fast),
        opacity var(--transition-fast);
      letter-spacing: 0.03em;
    }

    .btn span.icon {
      font-size: 16px;
    }

    .btn.secondary {
      background: rgba(148, 163, 184, 0.06);
      color: var(--text-main);
      box-shadow: none;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .btn.full {
      width: 100%;
      justify-content: center;
      padding: 14px 24px;
      font-size: 16px;
    }

    .btn.big {
      padding: 15px 26px;
      font-size: 18px;
    }

    .btn:disabled {
      opacity: 0.65;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .btn:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.4);
    }

    .btn.secondary:not(:disabled):hover {
      box-shadow: 0 10px 25px rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.9);
    }

    .main-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 22px;
      align-items: stretch;
      margin-bottom: 16px;
    }

    .card {
      background: radial-gradient(circle at top left, #fefce8, #ffffff 55%);
      border-radius: var(--radius-xl);
      padding: 22px 22px 20px;
      box-shadow: var(--shadow-soft);
      border: 1px solid var(--border-soft);
      backdrop-filter: blur(16px);
    }

    .card.result {
      background: radial-gradient(circle at top right, #e0f2fe, #ffffff 55%);
    }

    .section-title {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-title span.icon {
      font-size: 20px;
    }

    .reaction-top-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .reaction-panel {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr);
      gap: 18px;
      align-items: center;
    }

    .reaction-pad {
      width: 220px;
      height: 220px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      cursor: pointer;
      user-select: none;
      transition: background var(--transition-med),
        box-shadow var(--transition-med), transform var(--transition-med);
      box-shadow: 0 16px 50px rgba(15, 23, 42, 0.35);
      color: #0b1120;
      font-weight: 700;
      font-size: 18px;
    }

    .reaction-pad span.main-text {
      display: block;
      margin-bottom: 6px;
      font-size: 19px;
    }

    .reaction-pad span.sub-text {
      font-size: 13px;
      opacity: 0.9;
    }

    .pad-idle {
      background: radial-gradient(circle at 30% 0%, #e0f2fe, #f9fafb);
    }

    .pad-waiting {
      background: radial-gradient(circle at 30% 0%, #f97316, #fee2e2);
      animation: pulse-wait 1.2s infinite;
    }

    .pad-ready {
      background: radial-gradient(circle at 30% 0%, #4ade80, #bbf7d0);
      animation: pulse-ready 0.9s infinite;
    }

    .pad-too-early {
      background: radial-gradient(circle at 30% 0%, #f97373, #fecaca);
      animation: shake 300ms ease-in-out;
    }

    .pad-done {
      background: radial-gradient(circle at 30% 0%, #a855f7, #e9d5ff);
    }

    @keyframes pulse-wait {
      0% { transform: translateY(0) scale(1); box-shadow: 0 16px 50px rgba(248, 113, 113, 0.5); }
      50% { transform: translateY(2px) scale(0.99); box-shadow: 0 10px 30px rgba(248, 113, 113, 0.3); }
      100% { transform: translateY(0) scale(1); box-shadow: 0 16px 50px rgba(248, 113, 113, 0.5); }
    }

    @keyframes pulse-ready {
      0% { transform: translateY(0) scale(1); box-shadow: 0 16px 50px rgba(34, 197, 94, 0.5); }
      50% { transform: translateY(2px) scale(0.99); box-shadow: 0 10px 30px rgba(34, 197, 94, 0.3); }
      100% { transform: translateY(0) scale(1); box-shadow: 0 16px 50px rgba(34, 197, 94, 0.5); }
    }

    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-6px); }
      50% { transform: translateX(4px); }
      75% { transform: translateX(-3px); }
      100% { transform: translateX(0); }
    }

    .reaction-side {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .reaction-status {
      font-size: 13px;
      color: var(--text-muted);
    }

    .reaction-ms {
      font-size: 22px;
      font-weight: 700;
    }

    .reaction-ms span.unit {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-muted);
      margin-left: 6px;
    }

    .result-top {
      margin-bottom: 10px;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    .tier-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(255, 255, 255, 0.85);
      color: var(--text-muted);
    }

    .tier-pill.current {
      font-weight: 700;
      background: rgba(34, 197, 94, 0.1);
      border-color: rgba(34, 197, 94, 0.6);
      color: var(--accent-strong);
    }

    .tier-pill.gold {
      border-color: #facc15;
      background: #fef9c3;
      color: #92400e;
    }

    .tier-pill.silver {
      border-color: #cbd5f5;
      background: #e5e7eb;
      color: #374151;
    }

    .tier-pill.bronze {
      border-color: #f97316;
      background: #ffedd5;
      color: #7c2d12;
    }

    .tier-label {
      font-size: 30px;
      font-weight: 800;
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    .tier-label span.emoji {
      font-size: 32px;
    }

    .tier-description {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .footer {
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .footer a {
      color: #0ea5e9;
      text-decoration: none;
    }

    .footer a:hover {
      text-decoration: underline;
    }

    /* Admin panel */
    .admin-card {
      margin-top: 10px;
      font-size: 13px;
    }

    .admin-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 6px;
    }

    .admin-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .admin-field label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .admin-field input {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 7px 10px;
      font-size: 13px;
      width: 110px;
      outline: none;
    }

    .admin-status {
      font-size: 12px;
      color: var(--text-muted);
      margin-left: 2px;
      margin-top: 4px;
    }

    @media (max-width: 960px) {
      body {
        padding: 16px 12px;
      }

      .main-grid {
        grid-template-columns: minmax(0, 1fr);
      }

      .reaction-panel {
        grid-template-columns: minmax(0, 1fr);
        justify-items: center;
      }

      .reaction-pad {
        width: 200px;
        height: 200px;
      }
    }

    @media (max-width: 600px) {
      .card {
        border-radius: 20px;
        padding: 18px 16px 16px;
      }

      .brand-text-main {
        font-size: 20px;
      }

      .tier-label {
        font-size: 24px;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header class="app-header">
      <div class="brand">
        <div class="brand-logo">
          <span>‚ö°</span>
        </div>
        <div>
          <div class="brand-text-main">
            <span>Zama</span><span>Private Reaction Test</span>
          </div>
          <div class="brand-subtitle">
            Press when it turns green. Chain only sees your tier ‚Äî not your milliseconds.
          </div>
        </div>
      </div>

      <div class="chip-row">
        <div class="chip">
          <span>Network:</span>
          <strong>Sepolia FHEVM</strong>
        </div>
        <div class="chip" id="addressChip">
          <span>Wallet:</span><span id="addressBadge">Not connected</span>
        </div>
        <button class="btn" id="connectBtn">
          <span class="icon">ü¶ä</span><span id="connectBtnLabel">Connect Wallet</span>
        </button>
        <button class="btn secondary" id="disconnectBtn" style="display:none;">
          <span class="icon">‚èè</span><span>Disconnect</span>
        </button>
      </div>
    </header>

    <div class="main-grid">
      <!-- LEFT: reaction game -->
      <section class="card">
        <div class="section-title">
          <span class="icon">üéÆ</span><span>Private Reaction Mini-Game</span>
        </div>

        <div class="reaction-top-row">
          <button class="btn secondary big" id="startTestBtn">
            <span class="icon">üö¶</span>
            <span>Start new reaction test</span>
          </button>
          <div style="font-size:12px; color:var(--text-muted);">
            Contract:&nbsp;<strong>0x336AD8895440fB523EEA1573A8f13c0d7C5aE130</strong>
          </div>
        </div>

        <div class="reaction-panel">
          <div
            class="reaction-pad pad-idle"
            id="reactionPad"
            aria-label="Reaction test pad"
          >
            <div>
              <span class="main-text" id="padMainText">Tap to get ready</span>
              <span class="sub-text" id="padSubText">
                Wait for green, then tap as fast as you can.
              </span>
            </div>
          </div>

          <div class="reaction-side">
            <div class="reaction-status" id="reactionStatus">
              Waiting for you to start the test.
            </div>
            <div class="reaction-ms" id="reactionMsLabel"></div>
            <button class="btn full" id="sendToChainBtn" disabled>
              <span class="icon">üîê</span>
              <span id="sendToChainLabel">Encrypt & send to contract</span>
            </button>
          </div>
        </div>
      </section>

      <!-- RIGHT: result -->
      <section class="card result">
        <div class="section-title">
          <span class="icon">üèÖ</span><span>Your private category</span>
        </div>

        <div class="result-top">
          <div class="pill-row">
            <span class="tier-pill current">
              <span>Current result:</span>
              <strong id="tierChipLabel">No result yet</strong>
            </span>
          </div>
          <div class="pill-row">
            <span class="tier-pill gold">Gold ‚â§ fastest threshold</span>
            <span class="tier-pill silver">Silver ‚â§ mid threshold</span>
            <span class="tier-pill bronze">Bronze ‚â§ slowest threshold</span>
          </div>
        </div>

        <div class="tier-label">
          <span class="emoji" id="tierEmoji">‚è≥</span>
          <span id="tierText">Play the game and send your first result.</span>
        </div>
        <div class="tier-description" id="tierDescription">
          Once you submit an encrypted reaction time, you‚Äôll see your private tier here.
        </div>

        <button class="btn secondary full" id="refreshResultBtn">
          <span class="icon">üîÅ</span>
          <span>Refresh & decrypt last result</span>
        </button>
      </section>
    </div>

    <!-- Admin panel (owner only) -->
    <section class="card admin-card" id="adminCard" style="display:none;">
      <div class="section-title" style="margin-bottom:4px;">
        <span class="icon">üõ†</span><span>Admin: configure encrypted thresholds</span>
      </div>
      <div style="font-size:12px; color:var(--text-muted);">
        Values are local milliseconds. They are encrypted in your browser and sent
        to <code>setReactionTiers</code>. Recommended: Gold ‚â§ Silver ‚â§ Bronze.
      </div>

      <div class="admin-grid">
        <div class="admin-field">
          <label for="goldInput">Gold max (ms)</label>
          <input id="goldInput" type="number" min="0" max="65535" placeholder="e.g. 200" />
        </div>
        <div class="admin-field">
          <label for="silverInput">Silver max (ms)</label>
          <input id="silverInput" type="number" min="0" max="65535" placeholder="e.g. 300" />
        </div>
        <div class="admin-field">
          <label for="bronzeInput">Bronze max (ms)</label>
          <input id="bronzeInput" type="number" min="0" max="65535" placeholder="e.g. 450" />
        </div>
        <button class="btn secondary" id="setTiersBtn">
          <span class="icon">üîê</span><span id="setTiersLabel">Encrypt & set thresholds</span>
        </button>
      </div>
      <div class="admin-status" id="adminStatus"></div>
    </section>

    <div class="footer">
      <span>
        Built with Zama FHEVM ‚Ä¢ Only encrypted values reach the chain.
      </span>
      <span>
        Docs:
        <a href="https://docs.zama.ai/protocol/solidity-guides/smart-contract/operations/" target="_blank">Solidity FHE</a>
        ¬∑
        <a href="https://docs.zama.ai/protocol/relayer-sdk-guides/" target="_blank">Relayer SDK</a>
      </span>
    </div>
  </div>

  <script type="module">
    import { BrowserProvider, Contract } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";
    import {
      initSDK,
      createInstance,
      SepoliaConfig,
      generateKeypair
    } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";

    // Init Relayer SDK (WASM/workers)
    await initSDK();

    /* -------------------------- logging helpers (console only) -------------------------- */

    const safeStringify = (obj) => {
  try {
    let s = JSON.stringify(
      obj,
      (k, v) => (typeof v === "bigint" ? v.toString() + "n" : v)
    );
    // –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —á—É—Ç—å –ø–æ–¥—Ä–µ–∑–∞—Ç—å —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–µ –ª–æ–≥–∏
    if (s.length > 300) s = s.slice(0, 300) + "‚Ä¶";
    return s;
  } catch {
    try {
      return String(obj);
    } catch {
      return "[Unserializable value]";
    }
  }
};


    function appendLog(...parts) {
      const msg = parts
        .map((x) =>
          typeof x === "string"
            ? x
            : (() => {
                try {
                  return safeStringify(x);
                } catch {
                  return String(x);
                }
              })()
        )
        .join(" ");
      console.log("[log]", msg);
    }

    function normalizeDecryptedValue(v) {
      if (v == null) return null;
      if (typeof v === "boolean") return v ? 1n : 0n;
      if (typeof v === "bigint" || typeof v === "number") return BigInt(v);
      if (typeof v === "string") return BigInt(v);
      return BigInt(v.toString());
    }

    function shortAddress(addr) {
      if (!addr) return "‚Äî";
      return addr.slice(0, 6) + "‚Ä¶" + addr.slice(-4);
    }

    function normalizeChainId(id) {
      if (!id) return "";
      const s = String(id);
      if (/^\d+$/.test(s)) return "0x" + BigInt(s).toString(16);
      return s.toLowerCase();
    }

    /* ----------------------------- FHE core / config ---------------------------- */

    const DEFAULT_CHAIN_ID_HEX = "0xaa36a7"; // Sepolia
    const CONTRACT_ADDRESS = "0x336AD8895440fB523EEA1573A8f13c0d7C5aE130";

    // ABI with setReactionTiers + view functions
    const CONTRACT_ABI = [
      {
        inputs: [],
        name: "owner",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "bytes32", name: "encReactionMs", type: "bytes32" },
          { internalType: "bytes", name: "proof", type: "bytes" }
        ],
        name: "submitEncryptedReaction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getMyCategoryHandle",
        outputs: [
          { internalType: "bytes32", name: "tierHandle", type: "bytes32" },
          { internalType: "bool", name: "decided", type: "bool" }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "makeMyCategoryPublic",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "player", type: "address" }],
        name: "getPlayerMeta",
        outputs: [
          { internalType: "bool", name: "decided", type: "bool" },
          { internalType: "bool", name: "categoryPublic", type: "bool" }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "uint256", name: "programId", type: "uint256" }
        ],
        name: "getTierPolicyHandles",
        outputs: [
          { internalType: "bytes32", name: "maxGoldHandle", type: "bytes32" },
          { internalType: "bytes32", name: "maxSilverHandle", type: "bytes32" },
          { internalType: "bytes32", name: "maxBronzeHandle", type: "bytes32" },
          { internalType: "bool", name: "initialized", type: "bool" }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "bytes32", name: "encMaxGoldMs", type: "bytes32" },
          { internalType: "bytes32", name: "encMaxSilverMs", type: "bytes32" },
          { internalType: "bytes32", name: "encMaxBronzeMs", type: "bytes32" },
          { internalType: "bytes", name: "proof", type: "bytes" }
        ],
        name: "setReactionTiers",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];

    const _config = {
      contractAddress: null,
      abi: null,
      chainIdHex: DEFAULT_CHAIN_ID_HEX,
      relayerUrl: null,
      gatewayUrl: null,
      relayerNetworkConfig: SepoliaConfig
    };

    const _state = {
      provider: null,
      signer: null,
      contract: null,
      relayer: null,
      account: null,
      owner: null
    };

    function detectRelayerUrls() {
      const origin = window.location.origin;
      const hasLocalProxy =
        origin.includes("localhost:3443") || origin.includes("127.0.0.1:3443");
      if (hasLocalProxy) {
        return {
          relayerUrl: origin + "/relayer",
          gatewayUrl: origin + "/gateway"
        };
      }
      return {
        relayerUrl: "https://relayer.testnet.zama.org",
        gatewayUrl: "https://gateway.testnet.zama.org"
      };
    }

    async function ensureNetwork(chainIdHex) {
      if (!window.ethereum?.request) return false;
      let current = normalizeChainId(
        await window.ethereum.request({ method: "eth_chainId" }).catch(() => null)
      );
      if (current === chainIdHex) return true;

      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: chainIdHex }]
        });
      } catch (e) {
        if (e && e.code === 4902) {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: chainIdHex,
                chainName: "Sepolia",
                nativeCurrency: { name: "Sepolia ETH", symbol: "SEP", decimals: 18 },
                rpcUrls: ["https://rpc.sepolia.org"],
                blockExplorerUrls: ["https://sepolia.etherscan.io"]
              }
            ]
          });
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: chainIdHex }]
          });
        } else {
          appendLog("Network switch error:", e?.message || e);
          throw e;
        }
      }
      const after = normalizeChainId(
        await window.ethereum.request({ method: "eth_chainId" }).catch(() => null)
      );
      return after === chainIdHex;
    }

    async function configure({ contractAddress, abi } = {}) {
      if (!contractAddress || !abi) {
        throw new Error("configure(): contractAddress and abi are required");
      }
      _config.contractAddress = contractAddress;
      _config.abi = abi;
      const urls = detectRelayerUrls();
      _config.relayerUrl = urls.relayerUrl;
      _config.gatewayUrl = urls.gatewayUrl;
      appendLog("Configured core", _config);
    }

    async function connectWallet() {
      if (!_config.contractAddress || !_config.abi) {
        throw new Error("Call configure() first");
      }
      if (!window.ethereum?.request) {
        throw new Error("No EIP-1193 provider (MetaMask not found)");
      }

      await ensureNetwork(_config.chainIdHex);

      const provider = new BrowserProvider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();
      const account = await signer.getAddress();
      const contract = new Contract(_config.contractAddress, _config.abi, signer);

      const relayer = await createInstance({
        ..._config.relayerNetworkConfig,
        relayerUrl: _config.relayerUrl,
        gatewayUrl: _config.gatewayUrl,
        network: window.ethereum,
        debug: true
      });

      _state.provider = provider;
      _state.signer = signer;
      _state.contract = contract;
      _state.relayer = relayer;
      _state.account = account;

      try {
        const owner = await contract.owner();
        _state.owner = owner;
      } catch {
        _state.owner = null;
      }

      appendLog("Connected", { account, owner: _state.owner });

      if (window.ethereum?.on) {
        window.ethereum.on("accountsChanged", () => window.location.reload());
        window.ethereum.on("chainChanged", () => window.location.reload());
      }
      return { ..._state };
    }

    async function disconnectWallet() {
      _state.provider = null;
      _state.signer = null;
      _state.contract = null;
      _state.relayer = null;
      _state.account = null;
      _state.owner = null;
      appendLog("Disconnected");
    }

    async function autoConnectIfAuthorized() {
      if (!window.ethereum?.request) return false;
      try {
        const accs = await window.ethereum.request({ method: "eth_accounts" });
        if (accs && accs.length) {
          await connectWallet();
          return true;
        }
      } catch (e) {
        appendLog("autoConnectIfAuthorized error", e?.message || e);
      }
      return false;
    }

    function isOwner() {
      if (!_state.account || !_state.owner) return false;
      return _state.account.toLowerCase() === _state.owner.toLowerCase();
    }

    function randomSeed(modulus = 10000) {
      const buf = new Uint32Array(1);
      crypto.getRandomValues(buf);
      const raw = BigInt(buf[0]);
      const mod = BigInt(modulus);
      const res = mod === 0n ? raw : raw % mod;
      return Number(res);
    }

    async function encryptUint16(value) {
      if (!_state.relayer || !_state.account || !_config.contractAddress) {
        throw new Error("encryptUint16: relayer/account/contract not ready");
      }
      const n = Number(value);
      if (!Number.isInteger(n) || n < 0 || n > 65535) {
        throw new Error("encryptUint16: value must be in [0,65535]");
      }
      const input = _state.relayer.createEncryptedInput(
        _config.contractAddress,
        _state.account
      );
      input.add16(n);
      const { handles, inputProof } = await input.encrypt();
      appendLog("Encrypted uint16", { value: n, handle: handles[0] });
      return { handles, proof: inputProof };
    }

    async function encryptThreeUint16s(gold, silver, bronze) {
      if (!_state.relayer || !_state.account || !_config.contractAddress) {
        throw new Error("encryptThreeUint16s: relayer/account/contract not ready");
      }
      const nums = [gold, silver, bronze].map((v) => {
        const n = Number(v);
        if (!Number.isInteger(n) || n < 0 || n > 65535) {
          throw new Error("thresholds must be in [0,65535]");
        }
        return n;
      });

      const input = _state.relayer.createEncryptedInput(
        _config.contractAddress,
        _state.account
      );
      input.add16(nums[0]);
      input.add16(nums[1]);
      input.add16(nums[2]);

      const { handles, inputProof } = await input.encrypt();
      appendLog("Encrypted thresholds", { nums, handles });
      return { handles, proof: inputProof };
    }

    function buildValuePicker(out, pairs) {
      let map = {};
      if (out && typeof out === "object") {
        if (Array.isArray(out.clearValues) && pairs && pairs.length) {
          pairs.forEach((p, i) => {
            const h = String(p.handle || p).toLowerCase();
            map[h] = out.clearValues[i];
          });
        }
        if (!Object.keys(map).length &&
          typeof out.abiEncodedClearValues === "string" &&
          pairs &&
          pairs.length
        ) {
          const raw = out.abiEncodedClearValues.startsWith("0x")
            ? out.abiEncodedClearValues.slice(2)
            : out.abiEncodedClearValues;
          const values = [];
          for (let i = 0; i + 64 <= raw.length; i += 64) {
            const chunk = "0x" + raw.slice(i, i + 64);
            try { values.push(BigInt(chunk)); } catch { values.push(0n); }
          }
          pairs.forEach((p, i) => {
            const h = String(p.handle || p).toLowerCase();
            if (values[i] !== undefined) map[h] = values[i];
          });
        }
        if (!Object.keys(map).length) {
          for (const [k, v] of Object.entries(out)) {
            map[k.toLowerCase()] = v;
          }
        }
      }
      return (handle) => {
        if (!handle) return null;
        const k = String(handle).toLowerCase();
        const v = map[k];
        if (v === undefined) return null;
        return normalizeDecryptedValue(v);
      };
    }

    async function userDecryptMany(pairs) {
      if (!_state.relayer || !_state.signer || !_config.contractAddress) {
        throw new Error("userDecryptMany: not ready");
      }
      const kp = await generateKeypair();
      const startTs = Math.floor(Date.now() / 1000).toString();
      const daysValid = "7";

      const eip = _state.relayer.createEIP712(
        kp.publicKey,
        [_config.contractAddress],
        startTs,
        daysValid
      );

      const signature = await _state.signer.signTypedData(
        eip.domain,
        { UserDecryptRequestVerification: eip.types.UserDecryptRequestVerification },
        eip.message
      );

      const userAddr = await _state.signer.getAddress();

      const out = await _state.relayer.userDecrypt(
        pairs,
        kp.privateKey,
        kp.publicKey,
        signature.replace(/^0x/, ""),
        [_config.contractAddress],
        userAddr,
        startTs,
        daysValid
      );
      appendLog("userDecrypt result", out);
      return { out, pairs };
    }

    async function userDecryptHandles(handles) {
      const normalized = handles.map((h) =>
        typeof h === "string"
          ? { handle: h, contractAddress: _config.contractAddress }
          : {
              handle: h.handle,
              contractAddress: h.contractAddress || _config.contractAddress
            }
      );
      const { out, pairs } = await userDecryptMany(normalized);
      const pick = buildValuePicker(out, pairs);
      return { pick, raw: out, pairs };
    }

    /* --------------------------- UI elements & state --------------------------- */

    const addressBadge = document.getElementById("addressBadge");
    const connectBtn = document.getElementById("connectBtn");
    const connectBtnLabel = document.getElementById("connectBtnLabel");
    const disconnectBtn = document.getElementById("disconnectBtn");
    const addressChip = document.getElementById("addressChip");

    const reactionPad = document.getElementById("reactionPad");
    const padMainText = document.getElementById("padMainText");
    const padSubText = document.getElementById("padSubText");
    const reactionStatus = document.getElementById("reactionStatus");
    const reactionMsLabel = document.getElementById("reactionMsLabel");
    const sendToChainBtn = document.getElementById("sendToChainBtn");
    const sendToChainLabel = document.getElementById("sendToChainLabel");
    const startTestBtn = document.getElementById("startTestBtn");

    const tierChipLabel = document.getElementById("tierChipLabel");
    const tierEmoji = document.getElementById("tierEmoji");
    const tierText = document.getElementById("tierText");
    const tierDescription = document.getElementById("tierDescription");
    const refreshResultBtn = document.getElementById("refreshResultBtn");

    const adminCard = document.getElementById("adminCard");
    const goldInput = document.getElementById("goldInput");
    const silverInput = document.getElementById("silverInput");
    const bronzeInput = document.getElementById("bronzeInput");
    const setTiersBtn = document.getElementById("setTiersBtn");
    const setTiersLabel = document.getElementById("setTiersLabel");
    const adminStatus = document.getElementById("adminStatus");

    let gameState = "idle"; // idle | waiting | ready | done | too-early
    let waitTimeoutId = null;
    let greenTimestamp = 0;
    let lastReactionMs = null;
    let busy = false;
    let lastTierHandle = null;

    function setGameVisualState(state) {
      reactionPad.classList.remove("pad-idle", "pad-waiting", "pad-ready", "pad-too-early", "pad-done");
      if (state === "waiting") reactionPad.classList.add("pad-waiting");
      else if (state === "ready") reactionPad.classList.add("pad-ready");
      else if (state === "too-early") reactionPad.classList.add("pad-too-early");
      else if (state === "done") reactionPad.classList.add("pad-done");
      else reactionPad.classList.add("pad-idle");
    }

    function resetGameUI() {
      clearTimeout(waitTimeoutId);
      waitTimeoutId = null;
      gameState = "idle";
      lastReactionMs = null;
      setGameVisualState("idle");
      padMainText.textContent = "Tap to get ready";
      padSubText.textContent = "Wait for green, then tap as fast as you can.";
      reactionStatus.textContent = "Waiting for you to start the test.";
      reactionMsLabel.textContent = "";
      sendToChainBtn.disabled = true;
      sendToChainLabel.textContent = "Encrypt & send to contract";
    }

    function updateConnectionUI() {
      if (_state.account) {
        addressBadge.textContent = shortAddress(_state.account);
        connectBtnLabel.textContent = "Connected";
        connectBtn.style.background = "#16a34a";
        connectBtn.style.boxShadow = "0 14px 30px rgba(22, 163, 74, 0.45)";
        disconnectBtn.style.display = "inline-flex";
        addressChip.classList.add("highlight");
        adminCard.style.display = isOwner() ? "block" : "none";
      } else {
        addressBadge.textContent = "Not connected";
        connectBtnLabel.textContent = "Connect Wallet";
        connectBtn.style.background = "#0f172a";
        connectBtn.style.boxShadow = "0 14px 30px rgba(15, 23, 42, 0.35)";
        disconnectBtn.style.display = "none";
        addressChip.classList.remove("highlight");
        adminCard.style.display = "none";
      }
    }

    function requireWallet() {
      if (!_state.account) {
        alert("Please connect your wallet first.");
        throw new Error("Wallet not connected");
      }
    }

    function startReactionTest() {
      requireWallet();
      resetGameUI();
      gameState = "waiting";
      setGameVisualState("waiting");
      padMainText.textContent = "Get ready‚Ä¶";
      padSubText.textContent = "Don't tap yet. Wait for green!";
      reactionStatus.textContent = "Get ready. Green is coming‚Ä¶";
      appendLog("Reaction test started");

      const delay = 1600 + randomSeed(2000);
      waitTimeoutId = setTimeout(() => {
        gameState = "ready";
        setGameVisualState("ready");
        padMainText.textContent = "Go, go, go!";
        padSubText.textContent = "Tap the circle.";
        reactionStatus.textContent = "Go, go, go! Tap the circle.";
        greenTimestamp = performance.now();
      }, delay);
    }

    function handlePadClick() {
      if (busy) return;
      if (!_state.account) {
        alert("Please connect your wallet first.");
        return;
      }

      if (gameState === "idle") {
        startReactionTest();
        return;
      }

      if (gameState === "waiting") {
        clearTimeout(waitTimeoutId);
        waitTimeoutId = null;
        gameState = "too-early";
        setGameVisualState("too-early");
        padMainText.textContent = "Too soon!";
        padSubText.textContent = "Wait for green next time.";
        reactionStatus.textContent =
          "You clicked before it turned green. Try again.";
        reactionMsLabel.textContent = "";
        sendToChainBtn.disabled = true;
        setTimeout(() => resetGameUI(), 900);
        return;
      }

      if (gameState === "ready") {
        const now = performance.now();
        lastReactionMs = Math.max(0, Math.round(now - greenTimestamp));
        gameState = "done";
        setGameVisualState("done");
        padMainText.textContent = "Nice!";
        padSubText.textContent = "Now encrypt & send this time to the contract.";
        reactionStatus.textContent =
          "Local reaction measured. Ready to encrypt and send.";
        reactionMsLabel.innerHTML =
          lastReactionMs.toString() +
          '<span class="unit">ms (local only)</span>';
        sendToChainBtn.disabled = false;
        appendLog("Reaction measured", { ms: lastReactionMs });
        return;
      }

      if (gameState === "done" || gameState === "too-early") {
        startReactionTest();
      }
    }

    function mapTierToUi(value) {
      const n = Number(value ?? 0);
      if (!Number.isFinite(n)) {
        return { label: "Unknown", emoji: "‚ùì", desc: "" };
      }
      if (n <= 0) {
        return {
          label: "Too slow",
          emoji: "üê¢",
          desc:
            "Your encrypted reaction time did not cross any of the thresholds."
        };
      }
      if (n === 1) {
        return {
          label: "Bronze",
          emoji: "ü•â",
          desc:
            "You're within the slowest encrypted threshold. Bronze means you're in."
        };
      }
      if (n === 2) {
        return {
          label: "Silver",
          emoji: "ü•à",
          desc:
            "Nice reflexes! You beat the encrypted Silver threshold."
        };
      }
      if (n >= 3) {
        return {
          label: "Gold",
          emoji: "ü•á",
          desc:
            "Lightning fast! You're under the encrypted Gold threshold."
        };
      }
      return { label: "Unknown", emoji: "‚ùì", desc: "" };
    }

    async function refreshAndDecryptTier() {
      try {
        requireWallet();
        const [tierHandle, decided] =
          await _state.contract.getMyCategoryHandle();
        if (!decided) {
          tierChipLabel.textContent = "No result yet";
          tierEmoji.textContent = "‚è≥";
          tierText.textContent = "Play the game and send your first result.";
          tierDescription.textContent =
            "Once you submit an encrypted reaction time, you‚Äôll see your private tier here.";
          return;
        }

        lastTierHandle = tierHandle;
        appendLog("Fetched tierHandle", tierHandle);

        const { pick } = await userDecryptHandles([tierHandle]);
        const dec = pick(tierHandle);
        appendLog("Decrypted tier", dec?.toString?.());

        const ui = mapTierToUi(dec ?? 0n);
        tierChipLabel.textContent = ui.label;
        tierEmoji.textContent = ui.emoji;
        tierText.textContent = `Your private category: ${ui.label}`;
        tierDescription.textContent = ui.desc;
        reactionStatus.textContent =
          "Tier decrypted locally. Contract never saw the plaintext.";
      } catch (e) {
        appendLog("refreshAndDecryptTier error", e?.message || e);
        alert("Failed to decrypt your tier. Check console for details.");
      }
    }

    async function runEncryptedFlow() {
      try {
        requireWallet();
        if (lastReactionMs == null) {
          alert("Play the reaction game first.");
          return;
        }
        busy = true;
        sendToChainBtn.disabled = true;
        startTestBtn.disabled = true;
        sendToChainLabel.textContent = "Encrypting & sending‚Ä¶";

        const enc = await encryptUint16(lastReactionMs);

        appendLog("Calling submitEncryptedReaction‚Ä¶");
        const tx = await _state.contract.submitEncryptedReaction(
          enc.handles[0],
          enc.proof
        );
        appendLog("Tx sent", tx.hash);
        reactionStatus.textContent = "Waiting for transaction confirmation‚Ä¶";

        const receipt = await tx.wait();
        appendLog("Tx mined", { blockNumber: receipt.blockNumber });

        reactionStatus.textContent =
          "On-chain evaluation done. Decrypting your tier‚Ä¶";

        await refreshAndDecryptTier();
      } catch (e) {
        const msg = e?.shortMessage || e?.message || String(e);
        appendLog("Error in encrypted flow", msg);
        if (msg.includes("Tiers not configured")) {
          alert(
            "Tiers are not configured yet. Connect with the contract owner and use the admin panel to set Gold / Silver / Bronze thresholds."
          );
        } else {
          alert("Something went wrong. Check console for details.");
        }
      } finally {
        busy = false;
        sendToChainLabel.textContent = "Encrypt & send to contract";
        startTestBtn.disabled = false;
      }
    }

    async function setTiers() {
      try {
        requireWallet();
        if (!isOwner()) {
          alert("Only the contract owner can set thresholds.");
          return;
        }
        const gold = goldInput.value;
        const silver = silverInput.value;
        const bronze = bronzeInput.value;
        if (gold === "" || silver === "" || bronze === "") {
          alert("Fill in all three thresholds.");
          return;
        }

        busy = true;
        setTiersBtn.disabled = true;
        setTiersLabel.textContent = "Encrypting & setting‚Ä¶";
        adminStatus.textContent = "Encrypting thresholds in browser‚Ä¶";

        const enc = await encryptThreeUint16s(gold, silver, bronze);

        adminStatus.textContent = "Sending setReactionTiers transaction‚Ä¶";
        const tx = await _state.contract.setReactionTiers(
          enc.handles[0],
          enc.handles[1],
          enc.handles[2],
          enc.proof
        );
        appendLog("setReactionTiers tx sent", tx.hash);
        await tx.wait();
        adminStatus.textContent = "Thresholds updated on-chain.";
      } catch (e) {
        appendLog("setTiers error", e?.message || e);
        adminStatus.textContent = "Failed to set thresholds. See console.";
        alert("Failed to set thresholds. Check console for details.");
      } finally {
        busy = false;
        setTiersBtn.disabled = false;
        setTiersLabel.textContent = "Encrypt & set thresholds";
      }
    }

    /* ------------------------------ wiring events ------------------------------ */

    connectBtn.addEventListener("click", async () => {
      try {
        if (_state.account) {
          await disconnectWallet();
          updateConnectionUI();
          return;
        }
        connectBtn.disabled = true;
        connectBtnLabel.textContent = "Connecting‚Ä¶";
        await connectWallet();
        updateConnectionUI();
      } catch (e) {
        appendLog("connectWallet error", e?.message || e);
        alert("Failed to connect wallet. Check console.");
      } finally {
        connectBtn.disabled = false;
        connectBtnLabel.textContent = _state.account ? "Connected" : "Connect Wallet";
      }
    });

    disconnectBtn.addEventListener("click", async () => {
      await disconnectWallet();
      updateConnectionUI();
    });

    reactionPad.addEventListener("click", handlePadClick);
    startTestBtn.addEventListener("click", () => {
      try {
        startReactionTest();
      } catch (e) {
        appendLog("startTest error", e?.message || e);
      }
    });

    sendToChainBtn.addEventListener("click", () => {
      runEncryptedFlow();
    });

    refreshResultBtn.addEventListener("click", () => {
      refreshAndDecryptTier();
    });

    setTiersBtn.addEventListener("click", () => {
      setTiers();
    });

    /* ----------------------------- initial startup ----------------------------- */

    await configure({
      contractAddress: CONTRACT_ADDRESS,
      abi: CONTRACT_ABI
    });

    updateConnectionUI();
    appendLog("Page ready");

    await autoConnectIfAuthorized();
    if (_state.account) {
      updateConnectionUI();
      await refreshAndDecryptTier();
    }
  </script>
</body>
</html>
